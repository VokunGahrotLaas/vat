
%skeleton "lalr1.cc" // -*- C++ -*-
%require "3.8.2"

%header
%locations

%define api.namespace {vat::parse}
%define api.parser.class {yyParser}

%define api.value.type variant
%define api.token.constructor
%define api.token.raw
%define api.token.prefix {TOK_}

%define parse.assert
%define parse.trace
%define parse.error detailed
%define parse.lac full

/* This block of code will go into the header file generated by bison */
%code requires{
  // STL
  #include <memory>

  // vat
	#include <vat/parse/driver.hh>
  #include <vat/ast/all.hh>
}

// The parsing context.
%param { vat::parse::Driver& driver }

%code {
  // vat
	#include <vat/parse/lexer.hh>
  #include <vat/ast/print_visitor.hh>

  using namespace vat::ast;
  using namespace vat;

	#undef yylex
	#define yylex driver.lexer().yylex
}

// keywords
%token
  LET   "let"
  REC   "rec"
  FN    "fn"
  IF    "if"
  THEN  "then"
  ELSE  "else"
  TRUE  "true"
  FALSE "false"
;

// operators
%token
  ASSIGN    "="
  EQ        "=="
  NE        "!="
  LT        "<"
  LE        "<="
  GT        ">"
  GE        ">="
  MINUS     "-"
  PLUS      "+"
  STAR      "*"
  SLASH     "/"
  MOD       "%"
  POWER     "**"
  SEMICOLON ";"
  COLON     ":"
  ARROW     "->"
  COMMA     ","
  LPAREN    "("
  RPAREN    ")"
  LBRACE    "{"
  RBRACE    "}"
  EXCLAM    "!"
;

// exps
%token
  <std::string> IDENTIFIER "identifier"
  <int> NUMBER "number"
;

%token ERROR "error";
%token EOF 0 "end of file";

%nterm <vat::ast::SharedSeqExp> exps_plural call_exps_plural call_seq_exp fn_args fn_args.rec;
%nterm <vat::ast::SharedExp> exps exp rhs_exp fn_exp;
%nterm <vat::ast::SharedBlockExp> block_exp;
%nterm <vat::ast::SharedLetExp> let_exp fn_arg;
%nterm <vat::ast::SharedName> lhs_name rhs_name lhs_exp;
%nterm <vat::ast::SharedBool> bool_exp;

%left ";"
%precedence "then"
%precedence "else"
%left ":";
%left "=";
%left "==" "!=" "<" "<=" ">" ">=";
%left "+" "-";
%left "*" "/" "%";
%precedence POS NEG;
%right "**";
%precedence "(";

%printer { driver.yyout() << $$; } <std::string> <int>;
%printer {
  vat::ast::PrintVisitor pv{driver.yyout(), true};
  pv(*$$);
} <vat::ast::SharedExp>;

%%
%start input;
input: exps { driver.set_result($1); };

exps:
  exps_plural { $$ = $1; }
| exp
;

exps_plural:
  exps_plural ";" exp { $$ = $1; $$->location(@$); $$->push_back($3); }
| exp ";" exp         { $$ = std::make_shared<SeqExp>(@$, std::vector<SharedExp>{$1, $3}); }
;

call_exps_plural:
  exps_plural "," exp { $$ = $1; $$->location(@$); $$->push_back($3); }
| exp "," exp         { $$ = std::make_shared<SeqExp>(@$, std::vector<SharedExp>{$1, $3}); }
;

call_seq_exp:
  %empty { $$ = std::make_shared<SeqExp>(@$, std::vector<SharedExp>{}); }
| exp    { $$ = std::make_shared<SeqExp>(@$, std::vector<SharedExp>{$1}); }
| call_exps_plural
;

exp:
  rhs_exp
| lhs_exp { $$ = $1; }
;

fn_exp:
  "fn" lhs_name "(" fn_args ")" block_exp          { $$ = std::make_shared<LetExp>(@$, true, $2, nullptr, std::make_shared<FnExp>(@$, $4, $6)); }
| "fn" "(" fn_args ")" block_exp                   { $$ = std::make_shared<FnExp>(@$, $3, $5); }
| "fn" lhs_name "(" fn_args ")" "->" exp block_exp { $$ = std::make_shared<LetExp>(@$, true, $2, nullptr, std::make_shared<FnExp>(@$, $4, $8, $7)); }
| "fn" "(" fn_args ")" "->" exp block_exp          { $$ = std::make_shared<FnExp>(@$, $3, $7, $6); }
;

let_exp:
  "let" lhs_name ":" exp "=" exp       { $$ = std::make_shared<LetExp>(@$, false, $2, $4, $6); }
| "let" "rec" lhs_name ":" exp "=" exp { $$ = std::make_shared<LetExp>(@$, true, $3, $5, $7); }
| "let" lhs_name "=" exp               { $$ = std::make_shared<LetExp>(@$, false, $2, nullptr, $4); }
| "let" lhs_name ":" exp               { $$ = std::make_shared<LetExp>(@$, false, $2, $4, nullptr); }
;

rhs_exp:
  "if" exp "then" exp            { $$ = std::make_shared<IfExp>(@$, $2, $4); }
| "if" exp "then" exp "else" exp { $$ = std::make_shared<IfExp>(@$, $2, $4, $6); }
| "(" lhs_exp "=" exp ")"        { $$ = std::make_shared<AssignExp>(@$, $2, $4); }
| exp "==" exp                   { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Eq, $1, $3); }
| exp "!=" exp                   { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Ne, $1, $3); }
| exp "<" exp                    { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Lt, $1, $3); }
| exp "<=" exp                   { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Le, $1, $3); }
| exp ">" exp                    { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Gt, $1, $3); }
| exp ">=" exp                   { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Ge, $1, $3); }
| exp "+" exp                    { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Add, $1, $3); }
| exp "-" exp                    { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Sub, $1, $3); }
| exp "*" exp                    { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Mul, $1, $3); }
| exp "/" exp                    { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Div, $1, $3); }
| exp "%" exp                    { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Mod, $1, $3); }
| "-" exp %prec NEG              { $$ = std::make_shared<UnaryOp>(@$, UnaryOp::Neg, $2); }
| "+" exp %prec POS              { $$ = std::make_shared<UnaryOp>(@$, UnaryOp::Pos, $2); }
| exp "**" exp                   { $$ = std::make_shared<BinaryOp>(@$, BinaryOp::Pow, $1, $3); }
| exp "(" call_seq_exp ")"       { $$ = std::make_shared<CallExp>(@$, $1, $3); }
| "(" rhs_exp ")"                { $$ = $2; }
| NUMBER                         { $$ = std::make_shared<Number>(@$, $1); }
| bool_exp                       { $$ = $1; }
| let_exp                        { $$ = $1; }
| rhs_name                       { $$ = $1; }
| block_exp                      { $$ = $1; }
| fn_exp
;

lhs_exp:
  lhs_name            { $$ = $1; }
| "(" lhs_exp ")" { $$ = $2; }
;

bool_exp:
  "true"  { $$ = std::make_shared<Bool>(@$, true); }
| "false" { $$ = std::make_shared<Bool>(@$, false); }
;

block_exp: "{" exps "}" { $$ = std::make_shared<BlockExp>(@$, $2); };

lhs_name:
  IDENTIFIER { $$ = std::make_shared<Name>(@$, $1); }
;

rhs_name:
  "(" ")"    { $$ = std::make_shared<Name>(@$, "()"); }
| "!"        { $$ = std::make_shared<Name>(@$, "!"); }
;

fn_arg:
  lhs_name ":" exp { $$ = std::make_shared<LetExp>(@$, false, $1, $3, nullptr); }
;

fn_args:
  %empty      { $$ = std::make_shared<SeqExp>(@$, std::vector<SharedExp>{}); }
| fn_args.rec
;

fn_args.rec:
  fn_arg             { $$ = std::make_shared<SeqExp>(@$, std::vector<SharedExp>{$1}); }
| fn_args "," fn_arg { $$ = $1; $$->location(@$); $$->push_back($3); }
;
%%

void vat::parse::yyParser::error(location_type const& l, std::string const& m)
{
  driver.error(utils::ErrorType::Parsing, l) << m;
}
