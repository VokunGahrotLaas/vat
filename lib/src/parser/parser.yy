
%skeleton "lalr1.cc" // -*- C++ -*-
%require "3.8.2"

%header
%locations

%define api.namespace {vat::parser}
%define api.parser.class {yyParser}

%define api.value.type variant
%define api.token.constructor
%define api.token.raw
%define api.token.prefix {TOK_}

%define parse.assert
%define parse.trace
%define parse.error detailed
%define parse.lac full

/* This block of code will go into the header file generated by bison */
%code requires{
  // STL
  #include <memory>

  // vat
	#include <vat/parser/driver.hh>
  #include <vat/ast/all.hh>
}

// The parsing context.
%param { vat::parser::Driver& driver }

%code {
  // vat
	#include <vat/parser/lexer.hh>
  #include <vat/ast/print_visitor.hh>

  using namespace vat::ast;

	#undef yylex
	#define yylex driver.lexer().yylex
}

// keywords
%token
  FN "fn"
;

// operators
%token
  <std::string> ASSIGN  "="
  <std::string> MINUS   "-"
  <std::string> PLUS    "+"
  <std::string> STAR    "*"
  <std::string> SLASH   "/"
  <std::string> LPAREN  "("
  <std::string> RPAREN  ")"
  <std::string> POWER   "**"
;

// variables
%token
  <std::string> IDENTIFIER "identifier"
  <int> NUMBER "number"
;

%token EOF 0 "end of file"

%nterm <std::vector<vat::ast::SharedExp>> exps
%nterm <vat::ast::SharedExp> exp nu_exp simple_exp
%nterm <vat::ast::SharedName> name

%left "+" "-";
%left "*" "/";
%precedence POS NEG;
%right "**";

%printer { driver.yyout() << $$; } <std::string> <int>;
%printer {
  if ($$) {
    vat::ast::PrintVisitor pv{driver.yyout(), true};
    pv(*$$);
  } else {
    driver.yyout() << "(nullptr)";
  }
} <vat::ast::SharedExp>;
%printer {
  driver.yyout() << '{';
  for (auto const& e : $$)
    driver.yyout() << e << ',';
  driver.yyout() << '}';
} <std::vector<vat::ast::SharedExp>>;

%%
%start input;
input:
  exps { driver.set_result(std::make_shared<SeqExp>(@$, std::move($1))); }
| exp  { driver.set_result($1); }
;

exps:
  exps ";" exp { $$ = std::move($1); $$.push_back($3); }
| exps nu_exp { $$ = std::move($1); $$.push_back($2); }
| exp ";" exp  { $$ = std::vector<SharedExp>{$1, $3}; }
| exp nu_exp  { $$ = std::vector<SharedExp>{$1, $2}; }
;

exp:
  name "=" exp      { $$ = std::make_shared<AssignExp>(@$, $1, $3); }
| exp "+" exp       { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| exp "-" exp       { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| exp "*" exp       { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| exp "/" exp       { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| "-" exp %prec NEG { $$ = std::make_shared<UnaryOp>(@$, $1, $2); }
| "+" exp %prec POS { $$ = std::make_shared<UnaryOp>(@$, $1, $2); }
| exp "**" exp      { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| simple_exp
;

nu_exp:
  nu_exp "+" exp       { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| nu_exp "-" exp       { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| nu_exp "*" exp       { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| nu_exp "/" exp       { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| nu_exp "**" exp      { $$ = std::make_shared<BinaryOp>(@$, $2, $1, $3); }
| simple_exp
;

simple_exp:
  NUMBER            { $$ = std::make_shared<Number>(@$, $1); }
| name              { $$ = $1; }
| "(" exp ")"       { $$ = $2; }
;

name:
  IDENTIFIER      { $$ = std::make_shared<Name>(@$, $1); }
;
%%

void vat::parser::yyParser::error(const location_type& l, const std::string& m)
{
	driver.yyout() << l << ": " << m << std::endl;
}
