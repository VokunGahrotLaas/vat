
%skeleton "lalr1.cc" // -*- C++ -*-
%require "3.8.2"

%header
%locations

%define api.namespace {vat::parser}
%define api.parser.class {yyParser}

%define api.value.type variant
%define api.token.constructor
%define api.token.raw
%define api.token.prefix {TOK_}

%define parse.assert
%define parse.trace
%define parse.error detailed
%define parse.lac full

/* This block of code will go into the header file generated by bison */
%code requires{
  // STL
  #include <memory>

  // vat
	#include <vat/parser/driver.hh>
  #include <vat/ast/all.hh>
}

// The parsing context.
%param { vat::parser::Driver& driver }

%code {
  // vat
	#include <vat/parser/lexer.hh>
  #include <vat/ast/print_visitor.hh>

  using namespace vat::ast;

  #define LOC std::cref(driver.location())

	#undef yylex
	#define yylex driver.lexer().yylex
}

%token
  <std::string> ASSIGN  ":="
  <std::string> MINUS   "-"
  <std::string> PLUS    "+"
  <std::string> STAR    "*"
  <std::string> SLASH   "/"
  <std::string> LPAREN  "("
  <std::string> RPAREN  ")"
  <std::string> POWER   "**"
;

%token <std::string> IDENTIFIER "identifier"
%token <int> NUMBER "number"

%nterm <std::vector<vat::ast::SharedExp>> assignments
%nterm <vat::ast::SharedAssignExp> assignment
%nterm <vat::ast::SharedExp> exp nu_exp simple_exp
%nterm <vat::ast::SharedName> name

%left "+" "-";
%left "*" "/";
%precedence POS NEG;
%right "**";

%printer { driver.yyout() << $$; } <std::string> <int>;
%printer {
  if ($$) {
    vat::ast::PrintVisitor pv{driver.yyout(), true};
    pv(*$$);
  } else {
    driver.yyout() << "(nullptr)";
  }
} <vat::ast::SharedExp>;
%printer {
  driver.yyout() << '{';
  for (auto const& e : $$)
    driver.yyout() << e << ',';
  driver.yyout() << '}';
} <std::vector<vat::ast::SharedExp>>;

%%

%start unit;
unit:
  assignments nu_exp { $1.push_back($2); driver.set_result(std::make_shared<SeqExp>(LOC, std::move($1))); }
| exp                { driver.set_result($1); }
;

assignments:
  assignments assignment { $$ = std::move($1); $$.push_back($2); }
| assignment             { $$ = std::vector<SharedExp>{$1}; }
;

assignment:
  name ":=" exp { $$ = std::make_shared<AssignExp>(LOC, $1, $3); }
;

exp:
  exp "+" exp       { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| exp "-" exp       { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| exp "*" exp       { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| exp "/" exp       { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| "-" exp %prec NEG { $$ = std::make_shared<UnaryOp>(LOC, $1, $2); }
| "+" exp %prec POS { $$ = std::make_shared<UnaryOp>(LOC, $1, $2); }
| exp "**" exp      { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| simple_exp
;

nu_exp:
  nu_exp "+" exp       { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| nu_exp "-" exp       { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| nu_exp "*" exp       { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| nu_exp "/" exp       { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| nu_exp "**" exp      { $$ = std::make_shared<BinaryOp>(LOC, $2, $1, $3); }
| simple_exp
;

simple_exp:
  NUMBER            { $$ = std::make_shared<Number>(LOC, $1); }
| name              { $$ = $1; }
| "(" exp ")"       { $$ = $2; }
;

name:
  IDENTIFIER      { $$ = std::make_shared<Name>(LOC, $1); }
;

%%

void vat::parser::yyParser::error(const location_type& l, const std::string& m)
{
	driver.yyout() << l << ": " << m << std::endl;
}
